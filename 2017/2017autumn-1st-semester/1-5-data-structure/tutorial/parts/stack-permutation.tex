%%%%%%%%%%%%%%%
\begin{frame}{}
  \centerline{\LARGE Stackable Permutations}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{definition}[Stackable Permutations]
    \begin{columns}
      \column{0.40\textwidth}
	\begin{description}[\texttt{push(X, S)}:]
	  \item[\texttt{read(X)}:] $\texttt{in >> } X$
	  \item[\texttt{print(X)}:] $\texttt{out << } X$
	  \item[\texttt{push(X, S)}:] $S \Leftarrow X$
	  \item[\texttt{pop(X, S)}:] $X \Leftarrow S$
	\end{description}
      \column{0.55\textwidth}
	\centerline{\red{$Q_1:$} What are $X$ and \texttt{out} after \texttt{print(X)}}? 

	\centerline{\blue{$A_1:$} Elements move around.}

	\centerline{\red{$Q_2:$} $'a' >=<  X$, \texttt{top}(S)?}

	\centerline{\blue{$A_2:$} Yes.}
    \end{columns}

    \pause
    \[
      \texttt{in} = (1, \cdots, n) \xrightarrow[X = 0]{S = \emptyset} \texttt{out} = (a_1, \cdots, a_n)
    \]
  \end{definition}

  \vspace{0.30cm}
    fig here.
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{exampleblock}{DH 2.12: Stackable Permutations}
    \begin{enumerate}[(a)]
      \item \blueoverlay{Show}{2-} that the following permutations \emph{\blue{are}} stackable:
	\begin{enumerate}[(i)]
	  \item $(3, 2, 1)$
	  \item $(3, 4, 2, 1)$
	  \item $(3, 5, 7, 6, 8, 4, 9, 2, 10, 1)$
	\end{enumerate}
    \end{enumerate}
  \end{exampleblock}

  \pause
  \fignocaption{width = 0.40\textwidth}{figs/no-choice}

  % \begin{columns}
  %   \column{0.45\textwidth}
  %     \fignocaption{width = 0.80\textwidth}{figs/no-choice}
  %   \column{0.45\textwidth}
  %     \fignocaption{width = 0.50\textwidth}{figs/no-choice-best-choice}
  % \end{columns}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}[fragile]{}
  \begin{exampleblock}{DH 2.13: Stackable Permutations Checking Algorithm}
    To check whether a given permutation can be obtained by a stack.

    \centerline{\texttt{read} \quad \texttt{print} \quad \texttt{push} \quad \texttt{pop} \quad \blue{\texttt{is-empty}}}
  \end{exampleblock}


  % // not necessary!
  % if ('a' == X)
  %   print(X) 
  %   break
  \begin{columns}
    \column{0.45\textwidth}
      \begin{lstlisting}[style = Cstyle]
  X = 0
  S = $\emptyset$
      \end{lstlisting}

      \begin{lstlisting}[style = Cstyle]
foreach 'a' in out:
  if (! is-empty(S) 
      && 'a' == top(S))
    pop(S, X)
    print(X)
    break
  else $\cdots$ // T.B.C
      \end{lstlisting}
    \column{0.45\textwidth}
      \begin{lstlisting}[style = Cstyle]
  else // T.B.C
    while (in != $\emptyset$)
      read(X)
      if (X == 'a')
        print(X)
        break
      else if (X < 'a')
        push(X, S)
      else // (X > 'a')
        ERR
    ERR
      \end{lstlisting}
  \end{columns}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{exampleblock}{DH 2.12: Stackable Permutations}
    \begin{enumerate}[(a)]
      \setcounter{enumi}{1}
    \item \redoverlay{Prove}{2-} that the following permutations are \emph{\red{not}} stackable:
	\begin{enumerate}[(i)]
	  \item $(3, 1, 2)$
	  \item $(4, 5, 3, 7, 2, 1, 6)$
	\end{enumerate}
    \end{enumerate}
  \end{exampleblock}

  \pause
  \[
    (\red{3}, \red{1}, \red{2})
  \]

  \[
    (4, 5, 3, \red{7}, \red{2}, 1, \red{6})
  \]

  \pause
  \[
    a_i \cdots a_j \cdots a_k: i < j < k \land a_j < a_k < a_i
  \]

  \pause
  \[
    312\text{-Pattern}
  \]
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{theorem}[Stackable Permutations]
    A permutation $(a_1, \cdots, a_n)$ is stackable $\iff$ it is not the case that
    \[
      a_i \cdots a_j \cdots a_k: i < j < k \land a_j < a_k < a_i
    \]
  \end{theorem}

  \pause
  \begin{proof}
    \[
      \iff
    \]
    \pause
    \begin{columns}
      \column{0.45\textwidth}
        \[
	  \Rightarrow
	\]
      \column{0.45\textwidth}
        \[
	  \Leftarrow
	\]
    \end{columns}
  \end{proof}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{columns}
    \column{0.50\textwidth}
    \column{0.50\textwidth}
      \fignocaption{width = 0.80\textwidth}{figs/stack-railway-switching}
  \end{columns}

  \begin{theorem}[Equivalence]
    These two models ($S + X$ and $S$) are equivalent.
  \end{theorem}

  \pause
  \begin{proof}
    \centerline{\Large By simulations.}
    \vspace{0.20cm}
    \begin{columns}[t]
      \column{0.45\textwidth}
        Simulate $S$ by $S + X$:
	\begin{itemize}
	  \item \texttt{Push}
	  \item \texttt{Pop}
	\end{itemize}
      \column{0.45\textwidth}
        Simulate $S + X$ by $S$:
	\centerline{\large By iterative transformations.}
    \end{columns}
  \end{proof}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{theorem}[Stackable Permutations]
    A permutation $(a_1, \cdots, a_n)$ is stackable \blue{(on the model $S$)} $\iff$ it is not the case that
    \[
      a_i \cdots a_j \cdots a_k: i < j < k \land a_j < a_k < a_i
    \]
  \end{theorem}

  \begin{proof}
    \[
      \Longrightarrow
    \]
    \centerline{By contradiction.}
    \begin{description}[$a_j < a_k < a_i$:]
      \item[$a_j < a_k < a_i$:] When $a_i$ is poped, $a_j$ and $a_k$ are on the stack.
      \item[$j < k$:] $a_j$ is above $a_k$ on the stack.
      \item[$a_j < a_k$:] Contradiction.
    \end{description}
  \end{proof}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{theorem}[Stackable Permutations]
    A permutation $(a_1, \cdots, a_n)$ is stackable \blue{(on the model $S$)} $\iff$ it is not the case that
    \[
      a_i \cdots a_j \cdots a_k: i < j < k \land a_j < a_k < a_i
    \]
  \end{theorem}

  \begin{proof}
    \[
      \Longleftarrow
    \]
    \centerline{According to our algorithms and by contradiction.}

    \[
      a_j \notin \texttt{in} \land a_j \;!\!= \texttt{top}(S) \implies \exists k > j: a_k > a_j
    \]

    \[
      a_j, a_k \implies \exists i < j (< k): a_j < a_k < a_i
    \]
  \end{proof}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{exampleblock}{DH 2.12: Stackable Permutations}
    \begin{enumerate}[(a)]
      \setcounter{enumi}{2}
      \item How many permutations of $A_4$ \emph{cannot} be obtained by a stack?
    \end{enumerate}
  \end{exampleblock}

  \begin{align*}
    &(1, 4, 2, 3), (2, 4, 1, 3), (3, 1, 2, 4), (3, 1, 4, 2), (3, 4, 1, 2) \\
    &(4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2)
  \end{align*}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{exampleblock}{DH 2.12: Stackable Permutations}
    How many permutations of $A_n$ \emph{cannot} be obtained by a stack?
  \end{exampleblock}

  \pause

  \[
    \texttt{Push}: + \qquad \texttt{Pop}: -
  \]

  \[
    (3, 2, 5, 6, 1, 4): +++--++-+---
  \]
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{definition}[Admissible Sequences]
    A sequence of ``$+$'' and ``$-$'' is \blue{admissible} if and only if
    \pause
    \begin{enumerate}
      \item $\# \text{ of ``$+$''} = n \qquad \# \text{ of ``$-$''} = n$
      \item $\forall \text{ prefix}: (\# \text{ of ``$-$''}) \le (\# \text{ of ``$+$''})$
    \end{enumerate}
  \end{definition}

  \vspace{0.50cm}
  \pause
  \begin{theorem}
    Different admissible sequences correspond to different permutations.
  \end{theorem}

  \pause
  \begin{align*}
    +++--\red{+} \cdots \\
    +++--\red{-} \cdots \\
  \end{align*}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
  \begin{theorem}[Reflection Method]
    The number of stackable permutations is ${2n \choose n} - {2n \choose n-1}$.
  \end{theorem}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
\end{frame}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{frame}{}
\end{frame}
%%%%%%%%%%%%%%%
